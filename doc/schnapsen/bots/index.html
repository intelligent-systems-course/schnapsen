<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>schnapsen.bots API documentation</title>
<meta name="description" content="Create a bot in a separate .py and import them here, so that one can simply import
it by from schnapsen.bots import MyBot." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>schnapsen.bots</code></h1>
</header>
<section id="section-intro">
<p>Create a bot in a separate .py and import them here, so that one can simply import
it by from schnapsen.bots import MyBot.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Create a bot in a separate .py and import them here, so that one can simply import
it by from schnapsen.bots import MyBot.
&#34;&#34;&#34;
from .rand import RandBot
from .alphabeta import AlphaBetaBot
from .rdeep import RdeepBot
from .ml_bot import MLDataBot, MLPlayingBot, train_ML_model
from .gui.guibot import SchnapsenServer

__all__ = [&#34;RandBot&#34;, &#34;AlphaBetaBot&#34;, &#34;RdeepBot&#34;, &#34;MLDataBot&#34;, &#34;MLPlayingBot&#34;, &#34;train_ML_model&#34;, &#34;SchnapsenServer&#34;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="schnapsen.bots.alphabeta" href="alphabeta.html">schnapsen.bots.alphabeta</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="schnapsen.bots.example_bot" href="example_bot.html">schnapsen.bots.example_bot</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="schnapsen.bots.gui" href="gui/index.html">schnapsen.bots.gui</a></code></dt>
<dd>
<div class="desc"><p>Create a bot in a separate .py and import them here, so that one can simply import
it by from schnapsen.bots import MyBot.</p></div>
</dd>
<dt><code class="name"><a title="schnapsen.bots.ml_bot" href="ml_bot.html">schnapsen.bots.ml_bot</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="schnapsen.bots.rand" href="rand.html">schnapsen.bots.rand</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="schnapsen.bots.rdeep" href="rdeep.html">schnapsen.bots.rdeep</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="schnapsen.bots.train_ML_model"><code class="name flex">
<span>def <span class="ident">train_ML_model</span></span>(<span>replay_memory_filename: str = 'test_replay_memory', replay_memories_directory: str = 'ML_replay_memories', model_name: str = 'test_model', model_dir: str = 'ML_models', overwrite: bool = True) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def train_ML_model(replay_memory_filename: str = &#39;test_replay_memory&#39;,
                   replay_memories_directory: str = &#39;ML_replay_memories&#39;,
                   model_name: str = &#39;test_model&#39;, model_dir: str = &#34;ML_models&#34;, overwrite: bool = True) -&gt; None:
    # check if directory exists, and if not, then create it
    if not os.path.exists(model_dir):
        os.mkdir(model_dir)

    # Check if model exists already
    model_file_path = os.path.join(model_dir, model_name)
    if os.path.exists(model_file_path):
        if overwrite:
            print(
                &#34;Model with name: &#34; + model_name + &#34;, in directory: &#34; + model_dir + &#34;, exists already and will be overwritten as selected.&#34;)
            os.remove(model_file_path)
        else:
            raise ValueError(
                &#34;Model with name: &#34; + model_name + &#34;, in directory: &#34; + model_dir + &#34;, exists already and overwrite is set to False.&#34;
                &#34;\nNo new model will be trained, process terminates&#34;)

    replay_memory_file_path = os.path.join(replay_memories_directory, replay_memory_filename)

    # check that the replay memory dataset is found at the specified location
    if not os.path.exists(replay_memory_file_path):
        raise ValueError(f&#34;Dataset was not found at: {replay_memory_file_path} !&#34;)

    data: list[list[int]] = []
    targets: list[int] = []
    with open(file=replay_memory_file_path, mode=&#34;r&#34;) as replay_memory_file:
        for line in replay_memory_file:
            feature_string, won_label_str = line.split(&#34;||&#34;)
            feature_list_strings: list[str] = feature_string.split(&#34;,&#34;)
            feature_list = [int(feature) for feature in feature_list_strings]
            won_label = int(won_label_str)
            data.append(feature_list)
            targets.append(won_label)

    print(&#34;Dataset Statistics:&#34;)
    samples_of_wins = sum(targets)
    samples_of_losses = len(targets) - samples_of_wins
    print(&#34;Samples of wins:&#34;, samples_of_wins)
    print(&#34;Samples of losses:&#34;, samples_of_losses)

    # Play around with the model parameters below

    # HINT: Use tournament fast mode (-f flag) to quickly test your different models.

    # The following tuple specifies the number of hidden layers in the neural
    # network, as well as the number of layers, implicitly through its length.
    # You can set any number of hidden layers, even just one. Experiment and see what works.
    hidden_layer_sizes = (64, 32)

    # The learning rate determines how fast we move towards the optimal solution.
    # A low learning rate will converge slowly, but a large one might overshoot.
    learning_rate = 0.0001

    # The regularization term aims to prevent overfitting, and we can tweak its strength here.
    regularization_strength = 0.0001

    #############################################

    start = time.time()

    print(&#34;Starting training phase...&#34;)

    # Train a neural network
    learner = MLPClassifier(hidden_layer_sizes=hidden_layer_sizes, learning_rate_init=learning_rate,
                            alpha=regularization_strength, verbose=True, early_stopping=True, n_iter_no_change=6)
    # learner = sklearn.linear_model.LogisticRegression()

    model = learner.fit(data, targets)

    # Store the model
    joblib.dump(model, model_file_path)

    end = time.time()

    print(&#39;Done. Time to train:&#39;, (end - start) / 60, &#39;minutes.&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="schnapsen.bots.AlphaBetaBot"><code class="flex name class">
<span>class <span class="ident">AlphaBetaBot</span></span>
</code></dt>
<dd>
<div class="desc"><p>The Bot baseclass. Derive your own bots from this class and implement the get_move method to use it in games.</p>
<p>Besides the get_move method, it is also possible to override notify_trump_exchange and notify_game_end to get notified when these events happen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AlphaBetaBot(Bot):
    def __init__(self) -&gt; None:
        super().__init__()

    def get_move(self, player_perspective: PlayerPerspective, leader_move: Optional[Move]) -&gt; Move:
        raise NotImplementedError()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></b></code>:
<ul class="hlist">
<li><code><a title="schnapsen.game.Bot.get_move" href="../game.html#schnapsen.game.Bot.get_move">get_move</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_game_end" href="../game.html#schnapsen.game.Bot.notify_game_end">notify_game_end</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_trump_exchange" href="../game.html#schnapsen.game.Bot.notify_trump_exchange">notify_trump_exchange</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="schnapsen.bots.MLDataBot"><code class="flex name class">
<span>class <span class="ident">MLDataBot</span></span>
<span>(</span><span>bot: <a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a>, replay_memory_file_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>This class is defined to allow the creation of a training schnapsen bot dataset, that allows us to train a Machine Learning (ML) Bot
Practically, it helps us record how the game plays out according to a provided Bot behaviour; build what is called a "replay memory"
In more detail, we create one training sample for each decision the bot makes within a game, where a decision is an action selection for a specific game state.
Then we relate each decision with the outcome of the game, i.e. whether this bot won or not.
This way we can then train a bot according to the assumption that:
"decisions in earlier games that ended up in victories should be preferred over decisions that lead to lost games"
This class only records the decisions and game outcomes of the provided bot, according to its own perspective - incomplete game state knowledge.
The replay memories are stored under the directory "ML_replay_memories" in a file whose filename
is passed through the parameter "replay_memory_filename" when creating a MLDataBot object.</p>
<p>bot: the provided bot that will actually play the game and make decisions
replay_memory_filename: the filename under which the replay memory records will be stored, under the directory "ML_replay_memories"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MLDataBot(Bot):
    &#34;&#34;&#34;
    This class is defined to allow the creation of a training schnapsen bot dataset, that allows us to train a Machine Learning (ML) Bot
    Practically, it helps us record how the game plays out according to a provided Bot behaviour; build what is called a &#34;replay memory&#34;
    In more detail, we create one training sample for each decision the bot makes within a game, where a decision is an action selection for a specific game state.
    Then we relate each decision with the outcome of the game, i.e. whether this bot won or not.
    This way we can then train a bot according to the assumption that:
        &#34;decisions in earlier games that ended up in victories should be preferred over decisions that lead to lost games&#34;
    This class only records the decisions and game outcomes of the provided bot, according to its own perspective - incomplete game state knowledge.
    The replay memories are stored under the directory &#34;ML_replay_memories&#34; in a file whose filename
    is passed through the parameter &#34;replay_memory_filename&#34; when creating a MLDataBot object.
    &#34;&#34;&#34;

    def __init__(self, bot: Bot, replay_memory_file_path: str) -&gt; None:
        &#34;&#34;&#34;
        bot: the provided bot that will actually play the game and make decisions
        replay_memory_filename: the filename under which the replay memory records will be stored, under the directory &#34;ML_replay_memories&#34;
        &#34;&#34;&#34;
        self.bot: Bot = bot
        # self.my_history: Optional[list[tuple[PlayerPerspective, Optional[PartialTrick]]]] = None
        self.replay_memory_file_path: str = replay_memory_file_path

    def get_move(self, state: PlayerPerspective, leader_move: Optional[Move]) -&gt; Move:
        &#34;&#34;&#34;
            This function simply calls the get_move of the provided bot
        &#34;&#34;&#34;
        return self.bot.get_move(state=state, leader_move=leader_move)

    def notify_game_end(self, won: bool, player_perspective: &#39;PlayerPerspective&#39;) -&gt; None:
        &#34;&#34;&#34;
        When the game ends, this function retrieves the game history and more specifically all the replay memories that can
        be derived from it, and stores them in the form of state-actions vector representations and the corresponding outcome of the game

        param won: Did this bot win the game?
        param player_perspective: The final state of the game.
        &#34;&#34;&#34;
        # we retrieve the game history while actually discarding the last useless history record (which is after the game has ended), we know none of the Tricks can be None
        game_history: list[tuple[PlayerPerspective, Trick]] = cast(list[tuple[PlayerPerspective, Trick]], player_perspective.get_game_history()[:-1])
        # we also save the training label &#34;won or lost&#34;
        won_label = won

        # we iterate over all the rounds of the game
        for round_player_perspective, round_trick in game_history:

            if round_trick.is_trump_exchange():
                leader_move = round_trick.exchange
                follower_move = None
            else:
                leader_move = round_trick.leader_move
                follower_move = round_trick.follower_move

            # we do not want this representation to include actions that followed. So if this agent was the leader, we ignore the followers move
            if round_player_perspective.am_i_leader():
                follower_move = None

            state_actions_representation = create_state_and_actions_vector_representation(
                player_perspective=round_player_perspective, leader_move=leader_move, follower_move=follower_move)

            # append replay memory to file
            with open(file=self.replay_memory_file_path, mode=&#34;a&#34;) as replay_memory_file:
                # replay_memory_line: List[Tuple[list, number]] = [state_actions_representation, won_label]
                # writing to replay memory file in the form &#34;[feature list] || int(won_label)]
                replay_memory_file.write(f&#34;{str(state_actions_representation)[1:-1]} || {int(won_label)}\n&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="schnapsen.bots.MLDataBot.get_move"><code class="name flex">
<span>def <span class="ident">get_move</span></span>(<span>self, state: <a title="schnapsen.game.PlayerPerspective" href="../game.html#schnapsen.game.PlayerPerspective">PlayerPerspective</a>, leader_move: Optional[<a title="schnapsen.game.Move" href="../game.html#schnapsen.game.Move">Move</a>]) ‑> <a title="schnapsen.game.Move" href="../game.html#schnapsen.game.Move">Move</a></span>
</code></dt>
<dd>
<div class="desc"><p>This function simply calls the get_move of the provided bot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_move(self, state: PlayerPerspective, leader_move: Optional[Move]) -&gt; Move:
    &#34;&#34;&#34;
        This function simply calls the get_move of the provided bot
    &#34;&#34;&#34;
    return self.bot.get_move(state=state, leader_move=leader_move)</code></pre>
</details>
</dd>
<dt id="schnapsen.bots.MLDataBot.notify_game_end"><code class="name flex">
<span>def <span class="ident">notify_game_end</span></span>(<span>self, won: bool, player_perspective: PlayerPerspective) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>When the game ends, this function retrieves the game history and more specifically all the replay memories that can
be derived from it, and stores them in the form of state-actions vector representations and the corresponding outcome of the game</p>
<p>param won: Did this bot win the game?
param player_perspective: The final state of the game.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def notify_game_end(self, won: bool, player_perspective: &#39;PlayerPerspective&#39;) -&gt; None:
    &#34;&#34;&#34;
    When the game ends, this function retrieves the game history and more specifically all the replay memories that can
    be derived from it, and stores them in the form of state-actions vector representations and the corresponding outcome of the game

    param won: Did this bot win the game?
    param player_perspective: The final state of the game.
    &#34;&#34;&#34;
    # we retrieve the game history while actually discarding the last useless history record (which is after the game has ended), we know none of the Tricks can be None
    game_history: list[tuple[PlayerPerspective, Trick]] = cast(list[tuple[PlayerPerspective, Trick]], player_perspective.get_game_history()[:-1])
    # we also save the training label &#34;won or lost&#34;
    won_label = won

    # we iterate over all the rounds of the game
    for round_player_perspective, round_trick in game_history:

        if round_trick.is_trump_exchange():
            leader_move = round_trick.exchange
            follower_move = None
        else:
            leader_move = round_trick.leader_move
            follower_move = round_trick.follower_move

        # we do not want this representation to include actions that followed. So if this agent was the leader, we ignore the followers move
        if round_player_perspective.am_i_leader():
            follower_move = None

        state_actions_representation = create_state_and_actions_vector_representation(
            player_perspective=round_player_perspective, leader_move=leader_move, follower_move=follower_move)

        # append replay memory to file
        with open(file=self.replay_memory_file_path, mode=&#34;a&#34;) as replay_memory_file:
            # replay_memory_line: List[Tuple[list, number]] = [state_actions_representation, won_label]
            # writing to replay memory file in the form &#34;[feature list] || int(won_label)]
            replay_memory_file.write(f&#34;{str(state_actions_representation)[1:-1]} || {int(won_label)}\n&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></b></code>:
<ul class="hlist">
<li><code><a title="schnapsen.game.Bot.notify_trump_exchange" href="../game.html#schnapsen.game.Bot.notify_trump_exchange">notify_trump_exchange</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="schnapsen.bots.MLPlayingBot"><code class="flex name class">
<span>class <span class="ident">MLPlayingBot</span></span>
<span>(</span><span>model_name: str = 'test_model', model_dir: str = 'ML_models')</span>
</code></dt>
<dd>
<div class="desc"><p>This class loads a trained ML model and uses it to play</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MLPlayingBot(Bot):
    &#34;&#34;&#34;
    This class loads a trained ML model and uses it to play
    &#34;&#34;&#34;

    def __init__(self, model_name: str = &#39;test_model&#39;, model_dir: str = &#34;ML_models&#34;) -&gt; None:
        model_file_path = os.path.join(model_dir, model_name)
        if not os.path.exists(model_file_path):
            raise ValueError(&#34;Model could not be found at: &#34; + model_file_path)
        else:
            # load model
            self.__model = joblib.load(model_file_path)

    def get_move(self, player_perspective: &#39;PlayerPerspective&#39;, leader_move: Optional[Move]) -&gt; &#39;Move&#39;:
        # get the sate feature representation
        state_representation = get_state_feature_vector(player_perspective)
        # get the leader&#39;s move representation, even if it is None
        leader_move_representation = get_move_feature_vector(leader_move)
        # get all my valid moves
        my_valid_moves = player_perspective.valid_moves()
        # get the feature representations for all my valid moves
        my_move_representations: list[list[int]] = []
        for my_move in my_valid_moves:
            my_move_representations.append(get_move_feature_vector(my_move))

        # create all model inputs, for all bot&#39;s valid moves
        action_state_representations: list[list[int]] = []

        if player_perspective.am_i_leader():
            follower_move_representation = get_move_feature_vector(None)
            for my_move_representation in my_move_representations:
                action_state_representations.append(

                    state_representation + my_move_representation + follower_move_representation)
        else:
            for my_move_representation in my_move_representations:
                action_state_representations.append(
                    state_representation + leader_move_representation + my_move_representation)

        model_output = self.__model.predict_proba(action_state_representations)
        winning_probabilities_of_moves = [outcome_prob[1] for outcome_prob in model_output]
        highest_value: float = -1
        best_move: Move
        for index, value in enumerate(winning_probabilities_of_moves):
            if value &gt; highest_value:
                highest_value = value
                best_move = my_valid_moves[index]
        assert best_move
        return best_move</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></b></code>:
<ul class="hlist">
<li><code><a title="schnapsen.game.Bot.get_move" href="../game.html#schnapsen.game.Bot.get_move">get_move</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_game_end" href="../game.html#schnapsen.game.Bot.notify_game_end">notify_game_end</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_trump_exchange" href="../game.html#schnapsen.game.Bot.notify_trump_exchange">notify_trump_exchange</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="schnapsen.bots.RandBot"><code class="flex name class">
<span>class <span class="ident">RandBot</span></span>
<span>(</span><span>seed: int)</span>
</code></dt>
<dd>
<div class="desc"><p>The Bot baseclass. Derive your own bots from this class and implement the get_move method to use it in games.</p>
<p>Besides the get_move method, it is also possible to override notify_trump_exchange and notify_game_end to get notified when these events happen.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RandBot(Bot):
    def __init__(self, seed: int) -&gt; None:
        self.seed = seed
        self.rng = random.Random(self.seed)

    def get_move(
        self,
        player_perspective: PlayerPerspective,
        leader_move: Optional[Move],
    ) -&gt; Move:
        moves = player_perspective.valid_moves()
        move = self.rng.choice(list(moves))
        return move

    def __repr__(self) -&gt; str:
        return f&#34;RandBot(seed={self.seed})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></b></code>:
<ul class="hlist">
<li><code><a title="schnapsen.game.Bot.get_move" href="../game.html#schnapsen.game.Bot.get_move">get_move</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_game_end" href="../game.html#schnapsen.game.Bot.notify_game_end">notify_game_end</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_trump_exchange" href="../game.html#schnapsen.game.Bot.notify_trump_exchange">notify_trump_exchange</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="schnapsen.bots.RdeepBot"><code class="flex name class">
<span>class <span class="ident">RdeepBot</span></span>
<span>(</span><span>num_samples: int, depth: int, rand: random.Random)</span>
</code></dt>
<dd>
<div class="desc"><p>The Bot baseclass. Derive your own bots from this class and implement the get_move method to use it in games.</p>
<p>Besides the get_move method, it is also possible to override notify_trump_exchange and notify_game_end to get notified when these events happen.</p>
<p>Create a new rdeep bot.</p>
<p>:param num_samples: how many samples to take per move
:param depth: how deep to sample
:param rand: the source of randomness for this Bot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RdeepBot(Bot):
    def __init__(self, num_samples: int, depth: int, rand: Random) -&gt; None:
        &#34;&#34;&#34;
        Create a new rdeep bot.

        :param num_samples: how many samples to take per move
        :param depth: how deep to sample
        :param rand: the source of randomness for this Bot
        &#34;&#34;&#34;
        assert num_samples &gt;= 1, f&#34;we cannot work with less than one sample, got {num_samples}&#34;
        assert depth &gt;= 1, f&#34;it does not make sense to use a dept &lt;1. got {depth}&#34;
        self.__num_samples = num_samples
        self.__depth = depth
        self.__rand = rand

    def get_move(self, state: &#39;PlayerPerspective&#39;, leader_move: Optional[&#39;Move&#39;]) -&gt; &#39;Move&#39;:
        # get the list of valid moves, and shuffle it such
        # that we get a random move of the highest scoring
        # ones if there are multiple highest scoring moves.
        moves = state.valid_moves()
        self.__rand.shuffle(moves)

        best_score = float(&#39;-inf&#39;)
        best_move = None
        for move in moves:
            sum_of_scores = 0.0
            for _ in range(self.__num_samples):
                gamestate = state.make_assumption(leader_move=leader_move, rand=self.__rand)
                score = self.__evaluate(gamestate, state.get_engine(), leader_move, move)
                sum_of_scores += score
            average_score = sum_of_scores / self.__num_samples
            if average_score &gt; best_score:
                best_score = average_score
                best_move = move
        assert best_move is not None
        return best_move

    def __evaluate(self, gamestate: GameState, engine: GamePlayEngine, leader_move: Optional[Move], my_move: Move) -&gt; float:
        &#34;&#34;&#34;
        Evaluates the value of the given state for the given player
        :param state: The state to evaluate
        :param player: The player for whom to evaluate this state (1 or 2)
        :return: A float representing the value of this state for the given player. The higher the value, the better the
                state is for the player.
        &#34;&#34;&#34;
        me: Bot
        leader_bot: Bot
        follower_bot: Bot

        if leader_move:
            # we know what the other bot played
            leader_bot = FirstFixedMoveThenBaseBot(RandBot(rand=self.__rand), leader_move)
            # I am the follower
            me = follower_bot = FirstFixedMoveThenBaseBot(RandBot(rand=self.__rand), my_move)
        else:
            # I am the leader bot
            me = leader_bot = FirstFixedMoveThenBaseBot(RandBot(rand=self.__rand), my_move)
            # We assume the other bot just random
            follower_bot = RandBot(self.__rand)

        new_game_state, _ = engine.play_at_most_n_tricks(game_state=gamestate, new_leader=leader_bot, new_follower=follower_bot, n=self.__depth)

        if new_game_state.leader.implementation is me:
            my_score = new_game_state.leader.score.direct_points
            opponent_score = new_game_state.follower.score.direct_points
        else:
            my_score = new_game_state.follower.score.direct_points
            opponent_score = new_game_state.leader.score.direct_points

        heuristic = my_score / (my_score + opponent_score)
        return heuristic</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></li>
<li>abc.ABC</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></b></code>:
<ul class="hlist">
<li><code><a title="schnapsen.game.Bot.get_move" href="../game.html#schnapsen.game.Bot.get_move">get_move</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_game_end" href="../game.html#schnapsen.game.Bot.notify_game_end">notify_game_end</a></code></li>
<li><code><a title="schnapsen.game.Bot.notify_trump_exchange" href="../game.html#schnapsen.game.Bot.notify_trump_exchange">notify_trump_exchange</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="schnapsen.bots.SchnapsenServer"><code class="flex name class">
<span>class <span class="ident">SchnapsenServer</span></span>
<span>(</span><span>host_name: str = '0.0.0.0', port: int = 8080)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and starts the schnapsen server</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SchnapsenServer:

    def __enter__(self) -&gt; &#39;SchnapsenServer&#39;:
        return self

    def __exit__(self,
                 exctype: Optional[Type[BaseException]],
                 excinst: Optional[BaseException],
                 exctb: Optional[TracebackType]
                 ) -&gt; bool:
        if excinst:
            print(&#34;Closing the server, because an Exception was raised&#34;)
            # by returning False, we indicate that the exception was not handled.
            return False
        else:
            print(&#34;Server closed&#34;)
            return True

    def __init__(self, host_name: str = &#34;0.0.0.0&#34;, port: int = 8080) -&gt; None:
        &#34;&#34;&#34;Creates and starts the schnapsen server&#34;&#34;&#34;
        self.__host_name = host_name
        self.__port = port
        self.__bots: dict[str, _StateExchange] = {}

        app = Flask(__name__, template_folder=&#39;template&#39;)
        app.config.update(
            PROPAGATE_EXCEPTIONS=True
        )
        self.__setup_routes(app)
        self.__process = Thread(target=app.run, kwargs={&#34;host&#34;: host_name, &#34;port&#34;: port, &#34;use_reloader&#34;: False, &#34;debug&#34;: True})
        print(f&#34;Starting the server on {self.__host_name}:{self.__port}&#34;)
        self.__process.start()

    def make_gui_bot(self, name: str) -&gt; Bot:
        bot = GUIBot(name, self)
        self.__bots[name] = _StateExchange(bot=bot, browser_game_started=False, is_state_ready=Event(), is_move_ready=Event(), state=None, leader_move=None, browser_move=None)
        return bot

    def _post_final_state(self, botname: str, state: PlayerPerspective) -&gt; None:
        state_exchange = self.__bots[botname]
        state_exchange.state = state
        state_exchange.is_game_over = True
        state_exchange.is_state_ready.set()

    def _get_move(self, botname: str, state: PlayerPerspective, leader_move: Optional[Move]) -&gt; Move:
        state_exchange = self.__bots[botname]
        state_exchange.is_move_ready.clear()
        state_exchange.state = state
        state_exchange.leader_move = leader_move
        state_exchange.is_state_ready.set()
        # we now wait for the browser to make the move
        state_exchange.is_move_ready.wait()
        move = state_exchange.browser_move
        assert move is not None
        return move

    def __sendmove(self, botname: str) -&gt; str:
        data = cast(Tuple[Optional[int], Optional[int]], request.get_json(force=True))
        old_move: Tuple[Optional[int], Optional[int]] = (data[0], data[1])
        move = _Old_GUI_Compatibility.convert_move(old_move)

        state_exchange = self.__bots[botname]
        state_exchange.browser_move = move
        state_exchange.is_state_ready.clear()
        state_exchange.is_move_ready.set()
        return self.__generate(botname=botname)

    def __generate(self, botname: str) -&gt; str:
        state_exchange = self.__bots[botname]
        state_exchange.is_state_ready.wait()

        state = state_exchange.state
        assert state  # cannot be None, because we waited for it.
        leader_move = state_exchange.leader_move
        json = _Old_GUI_Compatibility.player_game_state_to_json(state=state, leader_move=leader_move, game_over=state_exchange.is_game_over)
        return json

    def __setup_routes(self, app: Flask) -&gt; None:
        app.route(&#39;/&#39;, methods=[&#39;GET&#39;])(self._index)
        app.route(&#39;/game/&lt;botname&gt;&#39;, methods=[&#39;GET&#39;])(self.__game)
        app.route(&#39;/generate/&lt;botname&gt;&#39;, methods=[&#39;GET&#39;])(self.__generate)
        app.route(&#39;/sendmove/&lt;botname&gt;&#39;, methods=[&#39;POST&#39;])(self.__sendmove)

    def _index(self) -&gt; str:
        bots = [(botname, state.browser_game_started) for botname, state in self.__bots.items()]
        return render_template(&#34;gamechooser.html&#34;, bots=bots)

    def __game(self, botname: str) -&gt; str:
        if self.__bots[botname].browser_game_started:
            abort(409, &#34;This game has already started&#34;)

        self.__bots[botname].browser_game_started = True
        return render_template(&#34;index_interactive.html&#34;, botname=botname)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="schnapsen.bots.SchnapsenServer.make_gui_bot"><code class="name flex">
<span>def <span class="ident">make_gui_bot</span></span>(<span>self, name: str) ‑> <a title="schnapsen.game.Bot" href="../game.html#schnapsen.game.Bot">Bot</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_gui_bot(self, name: str) -&gt; Bot:
    bot = GUIBot(name, self)
    self.__bots[name] = _StateExchange(bot=bot, browser_game_started=False, is_state_ready=Event(), is_move_ready=Event(), state=None, leader_move=None, browser_move=None)
    return bot</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="schnapsen" href="../index.html">schnapsen</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="schnapsen.bots.alphabeta" href="alphabeta.html">schnapsen.bots.alphabeta</a></code></li>
<li><code><a title="schnapsen.bots.example_bot" href="example_bot.html">schnapsen.bots.example_bot</a></code></li>
<li><code><a title="schnapsen.bots.gui" href="gui/index.html">schnapsen.bots.gui</a></code></li>
<li><code><a title="schnapsen.bots.ml_bot" href="ml_bot.html">schnapsen.bots.ml_bot</a></code></li>
<li><code><a title="schnapsen.bots.rand" href="rand.html">schnapsen.bots.rand</a></code></li>
<li><code><a title="schnapsen.bots.rdeep" href="rdeep.html">schnapsen.bots.rdeep</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="schnapsen.bots.train_ML_model" href="#schnapsen.bots.train_ML_model">train_ML_model</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="schnapsen.bots.AlphaBetaBot" href="#schnapsen.bots.AlphaBetaBot">AlphaBetaBot</a></code></h4>
</li>
<li>
<h4><code><a title="schnapsen.bots.MLDataBot" href="#schnapsen.bots.MLDataBot">MLDataBot</a></code></h4>
<ul class="">
<li><code><a title="schnapsen.bots.MLDataBot.get_move" href="#schnapsen.bots.MLDataBot.get_move">get_move</a></code></li>
<li><code><a title="schnapsen.bots.MLDataBot.notify_game_end" href="#schnapsen.bots.MLDataBot.notify_game_end">notify_game_end</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="schnapsen.bots.MLPlayingBot" href="#schnapsen.bots.MLPlayingBot">MLPlayingBot</a></code></h4>
</li>
<li>
<h4><code><a title="schnapsen.bots.RandBot" href="#schnapsen.bots.RandBot">RandBot</a></code></h4>
</li>
<li>
<h4><code><a title="schnapsen.bots.RdeepBot" href="#schnapsen.bots.RdeepBot">RdeepBot</a></code></h4>
</li>
<li>
<h4><code><a title="schnapsen.bots.SchnapsenServer" href="#schnapsen.bots.SchnapsenServer">SchnapsenServer</a></code></h4>
<ul class="">
<li><code><a title="schnapsen.bots.SchnapsenServer.make_gui_bot" href="#schnapsen.bots.SchnapsenServer.make_gui_bot">make_gui_bot</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>